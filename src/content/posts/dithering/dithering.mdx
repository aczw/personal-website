---
title: Dithering
posted: 2025-12-24T21:09:00.000-05

slug: dithering
---

outline

- check all commits prefixed with "webgpu:"
- i had many video buffering issues at first. i did two things to fix them
  - first, i originally tried loading all videos at once. this caused the current video to stutter because there were multiple network connections at once. now, on video transition, it plays the next video, and only starts preloading the next next one. _show code_
  - second, i simply decreased the video file sizes. i didn't have a consistent set of formats for each video. all of them had at least a mp4, but this resulted in 10-20 MB videos. i took some time to add missing format versions for all videos, including a WebM version and a "smaller" MP4 video with a lower resolution. decreasing the amount of data needed to be fetched is the most direct way of dealing with buffering issues.
  - i also tried adding a
    ```html
    <link
      rel="preload"
      href="https://..."
      as="video"
      type="video/mp4"
      fetchpriority="high"
      crossorigin="anonymous"
    />
    ```
    link preload for my video, but this behavior seems to be inconsistent and is at least disabled on Chromium for now. See [here](https://chromium-review.googlesource.com/c/chromium/src/+/1440522) and [here](https://issues.chromium.org/issues/40632962) for details.
- I wanted to achieve the effect [seen here](https://dithering.niccolofanton.dev), where it seems like the dithering is applied on top of a pixelization pass. Fortunately, we actually don't need two separate render passes. I realized that just like how we can offset the UV sample values, we can do the same for the pixel sample values for the Bayer matrix. Currently, it's hardcoded to check every pixel because we use `gl_FragCoord.xy` directly. We can define a separate pixel size for just the Bayer matrix instead.
- `requestVideoFrameCallback()`: https://web.dev/articles/requestvideoframecallback-rvfc, https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement/requestVideoFrameCallback
- passing video texture to GPU: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL
  - turns out `gl.texImage2D` can take a `HTMLVideoElement` as the source, which to me is an incredible integration of the classic OpenGL API with web technology. like, in hindsight, _obviously_ this should work, duh! https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL
- after seemingly getting it to work on desktop, it was time to fix all the broken things on iOS, as usual.
  - first, turns out iOS will immediately full screen play videos on page load unless you add playsInline, so i did that
  - with iOS 26, safari has completely altered the tab bar. i do agree it looks much better, but it also means we can't use display fixed anymore because just covering the viewport isn't enough anymore: _show picture_. instead im probably going to have to do some stupif shit to fix this idk man
- we can make some simplifications. first, we never bother with colored dithering and only work with grayscale values. therefore, we can treat the dithered value as an interpolation value `t` that we use to sample our true color palette.
