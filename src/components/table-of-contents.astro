---
import type { MarkdownHeading } from "astro";
import type { HTMLAttributes } from "astro/types";

type Props = HTMLAttributes<"aside"> & {
  headings: MarkdownHeading[];
};

const { headings, class: className, ...props } = Astro.props;

const MAX_HEADING_DEPTH = 4;

headings.forEach(({ depth, text }) => {
  if (depth === 1 || depth > MAX_HEADING_DEPTH) {
    throw new Error(`Heading "${text}" has depth ${depth}`);
  }
});
---

<aside
  class:list={["sticky top-0 h-screen overflow-y-auto", className]}
  {...props}
>
  <nav class="flex flex-col text-link-secondary">
    {
      headings.map(({ depth, slug, text }, index) => {
        return (
          <a
            href={`#${slug}`}
            class:list={[
              "pr-pad leading-[1.1] transition-colors first:pt-0 last:pb-pad hover:text-link-primary data-seen:text-link-primary data-seen:hover:text-link-primary-hover",

              depth === 2 ? "pt-[calc(var(--spacing-pad)*0.65)]" : "pt-0.5",

              headings[index + 1]?.depth === 2 ?
                "pb-[calc(var(--spacing-pad)*0.65)]"
              : "pb-0.5",
            ]}
            style={{
              paddingLeft: `calc(${2 * depth - 4} * var(--spacing-pad))`,
            }}
          >
            {text}
          </a>
        );
      })
    }
  </nav>
</aside>

<script>
  const observer = new IntersectionObserver((entries) =>
    entries.forEach((entry) => {
      const id = entry.target.id;
      const link = document.querySelector<HTMLAnchorElement>(
        `nav a[href="#${id}"]`,
      );

      const windowHeight = entry.rootBounds!.height;
      if (windowHeight && link) {
        if (entry.boundingClientRect.y < windowHeight) {
          link.dataset["seen"] = "";
        } else {
          delete link.dataset["seen"];
        }
      }
    }),
  );

  document
    .querySelectorAll("h2[id], h3[id], h4[id]")
    .forEach((heading) => observer.observe(heading));
</script>
