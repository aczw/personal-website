---
import { getEntries } from "astro:content";

import {
  BoxesIcon,
  ScrollTextIcon,
  WavesIcon,
  InfoIcon,
  SquareArrowRightIcon,
  SquareMousePointerIcon,
  SquareDashedMousePointerIcon,
} from "@lucide/astro";

import BaseLayout from "@/layouts/base-layout.astro";
import { HOMEPAGE_PROJECTS } from "@/scripts/constants";
import ContentDate from "@/components/content-date.astro";

const projects = await getEntries(
  HOMEPAGE_PROJECTS.map((id) => {
    return {
      collection: "projects" as const,
      id,
    };
  }),
);
---

<BaseLayout
  meta={{
    kind: "route",
    title: null,
    description: "Computer graphics student at the University of Pennsylvania.",
    ogImageParams:
      "Computer graphics student at the University of Pennsylvania.",
  }}
>
  <canvas
    id="dither"
    aria-hidden="true"
    class="pointer-events-none fixed inset-0 h-screen w-screen transition-opacity duration-1200 ease-in-out"
    style="opacity: 0;"></canvas>

  <main
    class="fixed inset-x-pad bottom-pad flex flex-col gap-pad *:overflow-hidden *:rounded-lg *:bg-sweater-10 *:p-pad *:leading-none *:not-dark:bg-sweater-1 480:right-auto 480:bottom-15 480:left-15 480:items-end *:480:w-[325px] md:flex-row"
  >
    <section id="nav" class="space-y-pad">
      <h1 class="cursor-default space-y-0.5 bordered p-pad">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="1.5rem"
          height="1.5rem"
          viewBox="0 0 25 25"
          aria-hidden="true"
          class="peer fill-sweater-5 transition-[rotate_fill] not-dark:fill-sweater-6 hover:-rotate-13 hover:fill-sweater-4 not-dark:hover:fill-sweater-7"
        >
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M.626.626a2.139 2.139 0 0 1 3.025 0l1.82 1.821A12.2 12.2 0 0 1 12.536.21a12.2 12.2 0 0 1 7.022 2.21L21.35.625a2.139 2.139 0 0 1 3.025 3.025L22.58 5.443a12.2 12.2 0 0 1 2.21 7.022 12.2 12.2 0 0 1-2.238 7.063l1.82 1.821a2.139 2.139 0 1 1-3.024 3.025l-1.833-1.833a12.2 12.2 0 0 1-6.981 2.18 12.2 12.2 0 0 1-7.023-2.209L3.65 24.374a2.139 2.139 0 1 1-3.025-3.025l1.862-1.861a12.2 12.2 0 0 1-2.21-7.023c0-2.594.806-5 2.181-6.981L.626 3.65a2.139 2.139 0 0 1 0-3.025ZM8.61 19.414a7.943 7.943 0 0 0 3.925 1.03 7.944 7.944 0 0 0 3.88-1.005L12.5 15.524l-3.89 3.89Zm.866-6.914-3.89 3.89a7.943 7.943 0 0 1-1.03-3.925c0-1.408.364-2.731 1.005-3.88L9.476 12.5Zm6.048 0 3.935 3.934a7.944 7.944 0 0 0 1.055-3.969 7.943 7.943 0 0 0-1.03-3.925l-3.96 3.96Zm.935-6.984L12.5 9.476 8.566 5.54a7.943 7.943 0 0 1 3.969-1.055c1.426 0 2.766.374 3.924 1.03Z"
          ></path>
        </svg>

        <span
          class="text-[1.75rem] font-bold text-sweater-5 transition-colors not-dark:text-sweater-6 peer-hover:text-sweater-4 not-dark:peer-hover:text-sweater-7"
        >
          Charles Wang
        </span>
      </h1>

      <nav
        class="grid grid-cols-2 bordered *:flex *:items-center *:justify-between *:gap-pad *:p-pad *:text-(length:--text-lg) *:font-bold *:text-link-primary *:transition-colors *:hover:bg-line *:hover:text-link-primary-hover"
      >
        <a
          href="/projects"
          class="border-r-(length:--border-w) border-b-(length:--border-w) border-style"
        >
          Portfolio <BoxesIcon size={18} class="stroke-icon" />
        </a>
        <a href="/posts" class="border-b-(length:--border-w) border-style">
          Posts <ScrollTextIcon size={18} class="stroke-icon" />
        </a>
        <a href="/extra" class="border-r-(length:--border-w) border-style">
          Extra <WavesIcon size={18} class="stroke-icon" />
        </a>
        <a href="/about">About <InfoIcon size={18} class="stroke-icon" /></a>
      </nav>
    </section>

    <section hidden id="panel-container">
      <div
        id="panel-border-wrapper"
        class="border-r-(length:--border-w) border-b-(length:--border-w) border-style"
      >
      </div>
    </section>

    <section class="space-y-pad">
      <div class="bordered">
        {
          projects.map(({ id, data: { name, metadata } }, index) => (
            <a
              data-project-id={id}
              data-playing={index === 0 ? "true" : "false"}
              href={`/projects/${id}`}
              class="group hidden border-b-(length:--border-w) border-style p-pad transition-colors hover:bg-line data-[playing=true]:flex"
            >
              <div class="grow space-y-pad">
                <p class="animate-pulse maple text-xs text-subtitle uppercase">
                  Now playing
                </p>

                <div class="space-y-1">
                  <h2 class="font-bold text-link-primary transition-colors group-hover:text-link-primary-hover">
                    {name}
                  </h2>
                  <ContentDate date={metadata.date} />
                </div>
              </div>

              <SquareArrowRightIcon size={18} class="shrink-0 stroke-icon" />
            </a>
          ))
        }

        <div class="p-pad">
          <div
            id="progress-bar"
            aria-label="Video progress"
            aria-valuemin="0"
            aria-valuemax="100"
            aria-valuenow="0"
            aria-valuetext="0% finished"
            class="h-2 w-full overflow-hidden rounded-full bg-sweater-9 not-dark:bg-sweater-2"
          >
            <div
              id="progress-value"
              class="h-full w-full origin-left bg-sweater-6 not-dark:bg-sweater-5"
              style="transform:scaleX(0.0);"
            >
            </div>
          </div>
        </div>
      </div>

      <button
        id="toggle-panel"
        class="group hidden w-full items-center justify-between gap-pad bordered p-pad font-bold text-link-primary transition-colors hover:bg-line hover:text-link-primary-hover 480:flex"
        data-state="closed"
      >
        <span class="hidden group-data-[state=open]:contents">
          Close panel <SquareDashedMousePointerIcon
            size={18}
            class="stroke-icon"
          />
        </span>

        <span class="hidden group-data-[state=closed]:contents">
          Open panel <SquareMousePointerIcon size={18} class="stroke-icon" />
        </span>
      </button>
    </section>
  </main>
</BaseLayout>

<script>
  import vertSource from "@/shaders/no-op.vert.glsl?raw";
  import fragSource from "@/shaders/dither.frag.glsl?raw";

  import {
    CDN_URL,
    HOMEPAGE_PROJECTS,
    DEFAULT_DARK_DITHER_SETTINGS,
    DEFAULT_LIGHT_DITHER_SETTINGS,
  } from "@/scripts/constants";
  import { saturate } from "@/scripts/util";
  import { type Dither } from "@/scripts/dither/types";
  import { initializePanel, type Panel } from "@/scripts/dither/panel";
  import { applyDitherSettings } from "@/scripts/dither/presets";

  const run = () => {
    const canvas = document.getElementById("dither") as HTMLCanvasElement;
    const gl = canvas.getContext("webgl2");

    if (!gl) {
      console.log("No WebGL 2 context found");
      return;
    }

    const createShader = (type: GLenum, source: string) => {
      const shader = gl.createShader(type)!;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;

      // Otherwise, an error occurred
      console.error("Error compiling shader:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);

      return null;
    };

    const vertShader = createShader(gl.VERTEX_SHADER, vertSource);
    const fragShader = createShader(gl.FRAGMENT_SHADER, fragSource);

    if (!vertShader || !fragShader) return;

    const program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Error linking program:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return;
    }

    const positionAttrLoc = gl.getAttribLocation(program, "v_position");
    const uvAttrLoc = gl.getAttribLocation(program, "v_uv");

    const videoFrameUnifLoc = gl.getUniformLocation(program, "u_video_frame");
    const dimensionsUnifLoc = gl.getUniformLocation(program, "u_dimensions");
    const ditherModeUnifLoc = gl.getUniformLocation(program, "u_dither_mode");
    const uvPixelSizeUnifLoc = gl.getUniformLocation(
      program,
      "u_uv_pixel_size",
    );
    const numQuantizedColorsUnifLoc = gl.getUniformLocation(
      program,
      "u_num_quantized_colors",
    );
    const biasUnifLoc = gl.getUniformLocation(program, "u_bias");
    const colorAUnifLoc = gl.getUniformLocation(program, "u_color_a");
    const colorBUnifLoc = gl.getUniformLocation(program, "u_color_b");
    const bayerMatrixSizeUnifLoc = gl.getUniformLocation(
      program,
      "u_bayer_matrix_size",
    );
    const orderedDitherSizeUnifLoc = gl.getUniformLocation(
      program,
      "u_ordered_dither_size",
    );

    // This only needs to be called once because we never switch shaders
    gl.useProgram(program);

    const positionBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]),
      gl.STATIC_DRAW,
    );

    const uvBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]),
      gl.STATIC_DRAW,
    );

    const vao = gl.createVertexArray();
    // We only ever use one VAO so binding it here sets it for the rest of time
    gl.bindVertexArray(vao);

    const indexBuf = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf);
    gl.bufferData(
      gl.ELEMENT_ARRAY_BUFFER,
      new Uint8Array([0, 1, 2, 2, 1, 3]),
      gl.STATIC_DRAW,
    );

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
    gl.enableVertexAttribArray(positionAttrLoc);
    // Attributes default to [0, 0, 0, 1] so we can get away with
    // setting size to just 2
    gl.vertexAttribPointer(positionAttrLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.enableVertexAttribArray(uvAttrLoc);
    gl.vertexAttribPointer(uvAttrLoc, 2, gl.FLOAT, false, 0, 0);

    const videoFrameTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + 0);
    gl.bindTexture(gl.TEXTURE_2D, videoFrameTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.uniform1i(videoFrameUnifLoc, 0);

    const nowPlayingAnchors: HTMLAnchorElement[] = [];
    const alreadyLoadedVideos = new WeakSet<HTMLVideoElement>();
    const videos: HTMLVideoElement[] = HOMEPAGE_PROJECTS.map((id) => {
      const element = document.querySelector(`[data-project-id="${id}"]`)!;
      nowPlayingAnchors.push(element as HTMLAnchorElement);

      const newVideo = document.createElement("video");
      newVideo.crossOrigin = "anonymous";
      newVideo.preload = "auto";
      newVideo.src = `${CDN_URL}/projects/${id}/cover.mp4`;
      newVideo.muted = true;
      // Prevents video from auto playing in fullscreen on page load on iOS
      // (even though we've never attached it to the DOM)
      newVideo.playsInline = true;

      return newVideo;
    });

    // Ready the first video for playing
    let currVideo!: HTMLVideoElement;
    alreadyLoadedVideos.add(videos[0]!);

    // Automatically start playing current video if the user switched tabs and
    // switched back (browsers pause the video in the background)
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible" && currVideo.paused) {
        currVideo.play();
      }
    });

    /**
     * Assumes we have more than one video. Come on. Otherwise it's boring
     */
    const transitionToNextVideo = (currentIndex: number): number => {
      const getNextIndex = (currentIndex: number) => {
        return currentIndex === videos.length - 1 ? 0 : currentIndex + 1;
      };

      const nextIndex = getNextIndex(currentIndex);
      currVideo = videos[nextIndex]!;
      currVideo.play();

      // Reset current video to the beginning for the next play
      videos[currentIndex]!.currentTime = 0;

      // Start preloading next next video if we haven't done it before
      const nextNextVideo = videos[getNextIndex(nextIndex)]!;
      if (!alreadyLoadedVideos.has(nextNextVideo)) {
        nextNextVideo.load();
        alreadyLoadedVideos.add(nextNextVideo);
      }

      return nextIndex;
    };

    // Transitions to index 0 aka plays the first video
    transitionToNextVideo(videos.length - 1);

    videos.forEach((video, index) => {
      video.addEventListener("ended", () => {
        const nextIndex = transitionToNextVideo(index);

        nowPlayingAnchors[index]!.dataset["playing"] = "false";
        nowPlayingAnchors[nextIndex]!.dataset["playing"] = "true";
      });
    });

    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)");

    const dither: Dither = {
      canvasSize: `0×0`,
      backend: "WebGL 2",
      ...structuredClone(
        prefersDark.matches ?
          DEFAULT_DARK_DITHER_SETTINGS
        : DEFAULT_LIGHT_DITHER_SETTINGS,
      ),
    };

    prefersDark.addEventListener("change", (ev) =>
      applyDitherSettings(
        dither,
        ev.matches ?
          DEFAULT_DARK_DITHER_SETTINGS
        : DEFAULT_LIGHT_DITHER_SETTINGS,
      ),
    );

    const panelContainerElt = document.getElementById("panel-container")!;
    const navElt = document.getElementById("nav")!;

    let panel: Panel | null = null;

    document.getElementById("toggle-panel")!.addEventListener("click", (ev) => {
      if (!panel) {
        panel = initializePanel(
          dither,
          document.getElementById("panel-border-wrapper")!,
        );
      } else {
        panel.pane.hidden = !panel.pane.hidden;
      }

      const elt = ev.currentTarget as HTMLButtonElement;
      elt.dataset["state"] = panel.pane.hidden ? "closed" : "open";

      if (panel.pane.hidden) {
        panelContainerElt.setAttribute("hidden", "");
        navElt.removeAttribute("hidden");
      } else {
        panelContainerElt.removeAttribute("hidden");
        navElt.setAttribute("hidden", "");
      }
    });

    const progressBarElt = document.getElementById("progress-bar")!;
    const progressValueElt = document.getElementById("progress-value")!;

    // The rate at which the current video updates (usually <= 60 FPS) is
    // usually slower than the screen's refresh rate. To prevent expensive
    // CPU-to-GPU texture copies of the same video data, we do it in this loop
    const onVideoFrameUpdate: VideoFrameRequestCallback = () => {
      panel?.fpsGraphs.video.begin();

      const progress = saturate(
        currVideo.duration > 0 ? currVideo.currentTime / currVideo.duration : 0,
      );

      const percentage = Math.round(progress * 100).toString();
      progressBarElt.setAttribute("aria-valuenow", percentage);
      progressBarElt.setAttribute("aria-valuetext", `${percentage}% finished`);
      progressValueElt.style.transform = `scaleX(${progress})`;

      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        currVideo,
      );

      panel?.fpsGraphs.video.end();
      currVideo.requestVideoFrameCallback(onVideoFrameUpdate);
    };

    currVideo.requestVideoFrameCallback((now, metadata) => {
      console.log("first frame ready!!");
      canvas.style.opacity = "1";
      onVideoFrameUpdate(now, metadata);
    });

    // On the other hand, uniform changes and resize events can occur at any
    // time and can't wait for the video, which often updates slower
    const draw: FrameRequestCallback = () => {
      panel?.fpsGraphs.draw.begin();

      // See https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
      if (
        canvas.width !== canvas.clientWidth ||
        canvas.height !== canvas.clientHeight
      ) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.uniform2i(dimensionsUnifLoc, gl.canvas.width, gl.canvas.height);
        dither.canvasSize = `${gl.canvas.width}×${gl.canvas.height}`;
      }

      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.uniform1i(ditherModeUnifLoc, dither.general.mode);
      gl.uniform1i(uvPixelSizeUnifLoc, dither.general.uvPixelSize);
      gl.uniform1i(
        numQuantizedColorsUnifLoc,
        dither.general.numQuantizedColors,
      );
      gl.uniform1f(biasUnifLoc, dither.general.bias);
      gl.uniform3f(
        colorAUnifLoc,
        dither.color.a.r,
        dither.color.a.g,
        dither.color.a.b,
      );
      gl.uniform3f(
        colorBUnifLoc,
        dither.color.b.r,
        dither.color.b.g,
        dither.color.b.b,
      );
      gl.uniform1i(bayerMatrixSizeUnifLoc, dither.ordered.bayerMatrixSize);
      gl.uniform1i(orderedDitherSizeUnifLoc, dither.ordered.ditheredSize);

      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);

      panel?.fpsGraphs.draw.end();
      requestAnimationFrame(draw);
    };
    requestAnimationFrame(draw);
  };

  run();
</script>
