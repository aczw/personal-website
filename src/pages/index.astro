---
import { getCollection, getEntries } from "astro:content";

import Link from "@/components/link.astro";
import {
  getFullDateFormatting,
  getMonthYearDateFormatting,
} from "@/scripts/util";
import MainLayout from "@/layouts/main-layout.astro";
import { CircleArrowRightIcon } from "@lucide/astro";
import GridSection from "@/components/grid-section.astro";
import TechList from "@/components/tech-list.astro";
import BaseLayout from "@/layouts/base-layout.astro";
import { CDN_URL } from "@/scripts/constants";

// Stuff below assumes this will only ever have 4 entries
const projects = await getEntries([
  { collection: "projects", id: "mini-minecraft" },
  { collection: "projects", id: "pbr-renderer" },
  { collection: "projects", id: "webgpu-clustered" },
  { collection: "projects", id: "door" },
]);

const showSubtitles = ["mini-minecraft", "door"];

let posts = await getCollection("posts");
posts = posts
  .sort((a, b) => b.data.posted.getTime() - a.data.posted.getTime())
  .slice(0, 3);
---

<BaseLayout
  meta={{
    kind: "route",
    title: null,
    description: "Computer graphics student at the University of Pennsylvania.",
    ogImageParams:
      "Computer graphics student at the University of Pennsylvania.",
  }}
>
  <div class="fixed bottom-0 left-0 space-y-pad-2 bg-sweater-8 p-pad-2">
    <header>
      <h1>Charles Wang</h1>

      <nav class="grid grid-cols-2">
        <a href="/projects">Portfolio</a>
        <a href="/posts">Posts</a>
        <a href="/fun">Stream</a>
        <a href="/about">About</a>
      </nav>
    </header>

    <main>
      <canvas
        id="dither"
        class="pointer-events-none fixed inset-0 -z-1 h-screen w-screen"
      ></canvas>

      <p>Now playing: Mini Minecraft</p>
    </main>

    <footer>
      <a>Email</a>
    </footer>
  </div>
</BaseLayout>

<script>
  import vertSource from "@/scripts/shaders/no-op.vert.glsl?raw";
  import fragSource from "@/scripts/shaders/dither.frag.glsl?raw";

  import { CDN_URL } from "@/scripts/constants";

  const run = () => {
    const canvas = document.getElementById("dither") as HTMLCanvasElement;
    const gl = canvas.getContext("webgl2");

    if (!gl) {
      console.log("No WebGL 2 context found");
      return;
    }

    const createShader = (type: GLenum, source: string) => {
      const shader = gl.createShader(type)!;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;

      // Otherwise, an error occurred
      console.log("Error compiling shader:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);

      return null;
    };

    const vertShader = createShader(gl.VERTEX_SHADER, vertSource);
    const fragShader = createShader(gl.FRAGMENT_SHADER, fragSource);

    if (!vertShader || !fragShader) return;

    const program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log("Error linking program:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return;
    }

    // TODO: replace with hardcoded layout locations?
    const positionAttrLoc = gl.getAttribLocation(program, "v_position");
    const uvAttrLoc = gl.getAttribLocation(program, "v_uv");
    const videoFrameUnifLoc = gl.getUniformLocation(program, "u_video_frame");

    const positionBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]),
      gl.STATIC_DRAW,
    );

    const uvBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]),
      gl.STATIC_DRAW,
    );

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const indexBuf = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf);
    gl.bufferData(
      gl.ELEMENT_ARRAY_BUFFER,
      new Uint8Array([0, 1, 2, 2, 1, 3]),
      gl.STATIC_DRAW,
    );

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
    gl.enableVertexAttribArray(positionAttrLoc);
    // Attributes default to [0, 0, 0, 1] so we can get away with
    // setting size to just 2
    gl.vertexAttribPointer(positionAttrLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.enableVertexAttribArray(uvAttrLoc);
    gl.vertexAttribPointer(uvAttrLoc, 2, gl.FLOAT, false, 0, 0);

    /**
     * @see https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
     */
    const resizeToDisplaySize = () => {
      const displayWidth = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;

      // Check if canvas needs to be resized
      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      }
    };

    const videoFrameTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + 0);
    gl.bindTexture(gl.TEXTURE_2D, videoFrameTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    let video = document.createElement("video");
    video.crossOrigin = "anonymous";
    video.preload = "auto";
    video.src = `${CDN_URL}/projects/mini-minecraft/cover-small.webm`;
    video.muted = true;
    video.loop = true;
    video.play();

    const draw = (
      _: DOMHighResTimeStamp,
      metadata: VideoFrameCallbackMetadata,
    ) => {
      resizeToDisplaySize();

      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.bindVertexArray(vao);

      gl.activeTexture(gl.TEXTURE0 + 0);
      gl.bindTexture(gl.TEXTURE_2D, videoFrameTexture);
      gl.uniform1i(videoFrameUnifLoc, 0);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        video,
      );

      console.log("draw:", metadata.mediaTime);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);

      video.requestVideoFrameCallback(draw);
    };

    video.requestVideoFrameCallback(draw);
  };

  run();
</script>
