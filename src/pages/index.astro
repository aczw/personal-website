---
import { getCollection, getEntries } from "astro:content";

import Link from "@/components/link.astro";
import {
  getFullDateFormatting,
  getMonthYearDateFormatting,
} from "@/scripts/util";
import { CircleArrowRightIcon } from "@lucide/astro";
import GridSection from "@/components/grid-section.astro";
import TechList from "@/components/tech-list.astro";
import BaseLayout from "@/layouts/base-layout.astro";
import { HOMEPAGE_PROJECTS } from "@/scripts/constants";

const projects = await getEntries(
  HOMEPAGE_PROJECTS.map((id) => {
    return {
      collection: "projects" as const,
      id,
    };
  }),
);

let posts = await getCollection("posts");
posts = posts
  .sort((a, b) => b.data.posted.getTime() - a.data.posted.getTime())
  .slice(0, 3);
---

<BaseLayout
  meta={{
    kind: "route",
    title: null,
    description: "Computer graphics student at the University of Pennsylvania.",
    ogImageParams:
      "Computer graphics student at the University of Pennsylvania.",
  }}
>
  <canvas
    id="dither"
    aria-hidden="true"
    class="pointer-events-none fixed inset-0 h-screen w-screen"></canvas>

  <div class="fixed bottom-0 left-0 space-y-pad-2 bg-sweater-8 p-pad-2">
    <header>
      <h1>Charles Wang</h1>

      <nav class="grid grid-cols-2">
        <a href="/projects">Portfolio</a>
        <a href="/posts">Posts</a>
        <a href="/fun">Stream</a>
        <a href="/about">About</a>
      </nav>
    </header>

    <main>
      <section class="border-(length:--border-w) border-line-bright">
        <div
          class="flex border-b-(length:--border-w) border-dashed border-line-dark leading-none"
        >
          <h2
            class="grow border-r-(length:--border-w) border-dashed border-line-dark p-pad"
          >
            Now playing
          </h2>
          <button
            id="play-pause"
            class="bottom shrink-0 p-pad transition-colors hover:bg-red-50"
          >
            Pause
          </button>
        </div>

        {
          projects.map(({ id, data: { name, metadata } }, index) => (
            <a
              data-project-id={id}
              data-playing={index === 0 ? "true" : "false"}
              href={`/projects/${id}`}
              class="hidden border-b-(length:--border-w) border-dashed border-line-dark p-pad transition-colors hover:bg-red-50 data-[playing=true]:block"
            >
              <h3>{name}</h3>
              <TechList tech={metadata.tech} />
            </a>
          ))
        }

        <div class="p-pad">
          <div
            id="progress-bar"
            aria-label="Video progress"
            aria-valuemin="0"
            aria-valuemax="100"
            aria-valuenow="0"
            class="h-2 w-full overflow-hidden rounded-full bg-sweater-9"
          >
            <div
              id="progress-value"
              class="h-full w-full origin-left bg-sweater-5"
              style="transform:scaleX(0.6);"
            >
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <a>Email</a>
    </footer>
  </div>
</BaseLayout>

<script>
  import { Pane, type BladeApi } from "tweakpane";
  import * as TpEssentialsPlugin from "@tweakpane/plugin-essentials";
  import type { FpsGraphBladeApi } from "@tweakpane/plugin-essentials";

  import vertSource from "@/shaders/no-op.vert.glsl?raw";
  import fragSource from "@/shaders/dither.frag.glsl?raw";

  import {
    CDN_URL,
    HOMEPAGE_PROJECTS,
    DEFAULT_DITHER_SETTINGS,
  } from "@/scripts/constants";
  import { saturate } from "@/scripts/util";
  import {
    DitherMode,
    BayerMatrixSize,
    type DitherSettings,
    type Dither,
  } from "@/scripts/dither/types";
  import { DITHER_PRESETS } from "@/scripts/dither/presets";

  const run = () => {
    const canvas = document.getElementById("dither") as HTMLCanvasElement;
    const gl = canvas.getContext("webgl2");

    if (!gl) {
      console.log("No WebGL 2 context found");
      return;
    }

    const createShader = (type: GLenum, source: string) => {
      const shader = gl.createShader(type)!;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;

      // Otherwise, an error occurred
      console.error("Error compiling shader:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);

      return null;
    };

    const vertShader = createShader(gl.VERTEX_SHADER, vertSource);
    const fragShader = createShader(gl.FRAGMENT_SHADER, fragSource);

    if (!vertShader || !fragShader) return;

    const program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Error linking program:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return;
    }

    // TODO: replace with hardcoded layout locations?
    const positionAttrLoc = gl.getAttribLocation(program, "v_position");
    const uvAttrLoc = gl.getAttribLocation(program, "v_uv");

    const videoFrameUnifLoc = gl.getUniformLocation(program, "u_video_frame");
    const dimensionsUnifLoc = gl.getUniformLocation(program, "u_dimensions");
    const ditherModeUnifLoc = gl.getUniformLocation(program, "u_dither_mode");
    const uvPixelSizeUnifLoc = gl.getUniformLocation(
      program,
      "u_uv_pixel_size",
    );
    const numQuantizedColorsUnifLoc = gl.getUniformLocation(
      program,
      "u_num_quantized_colors",
    );
    const biasUnifLoc = gl.getUniformLocation(program, "u_bias");
    const colorAUnifLoc = gl.getUniformLocation(program, "u_color_a");
    const colorBUnifLoc = gl.getUniformLocation(program, "u_color_b");
    const bayerMatrixSizeUnifLoc = gl.getUniformLocation(
      program,
      "u_bayer_matrix_size",
    );
    const orderedDitherSizeUnifLoc = gl.getUniformLocation(
      program,
      "u_ordered_dither_size",
    );

    // This only needs to be called once because we never switch shaders
    gl.useProgram(program);

    const positionBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]),
      gl.STATIC_DRAW,
    );

    const uvBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]),
      gl.STATIC_DRAW,
    );

    const vao = gl.createVertexArray();
    // We only ever use one VAO so binding it here sets it for the rest of time
    gl.bindVertexArray(vao);

    const indexBuf = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf);
    gl.bufferData(
      gl.ELEMENT_ARRAY_BUFFER,
      new Uint8Array([0, 1, 2, 2, 1, 3]),
      gl.STATIC_DRAW,
    );

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuf);
    gl.enableVertexAttribArray(positionAttrLoc);
    // Attributes default to [0, 0, 0, 1] so we can get away with
    // setting size to just 2
    gl.vertexAttribPointer(positionAttrLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.enableVertexAttribArray(uvAttrLoc);
    gl.vertexAttribPointer(uvAttrLoc, 2, gl.FLOAT, false, 0, 0);

    const videoFrameTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + 0);
    gl.bindTexture(gl.TEXTURE_2D, videoFrameTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.uniform1i(videoFrameUnifLoc, 0);

    const nowPlayingAnchors: HTMLAnchorElement[] = [];
    const alreadyLoadedVideos = new WeakSet<HTMLVideoElement>();
    const videos: HTMLVideoElement[] = HOMEPAGE_PROJECTS.map((id) => {
      const element = document.querySelector(`[data-project-id="${id}"]`)!;
      nowPlayingAnchors.push(element as HTMLAnchorElement);

      const newVideo = document.createElement("video");
      newVideo.crossOrigin = "anonymous";
      newVideo.preload = "auto";
      newVideo.src = `${CDN_URL}/projects/${id}/cover.mp4`;
      newVideo.muted = true;
      // Prevents video from auto playing in fullscreen on page load on iOS
      // (even though we've never attached it to the DOM)
      newVideo.playsInline = true;

      return newVideo;
    });

    // Ready the first video for playing
    let currVideo!: HTMLVideoElement;
    alreadyLoadedVideos.add(videos[0]!);

    // Automatically start playing current video if the user switched tabs and
    // switched back (browsers pause the video in the background)
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible" && currVideo.paused) {
        currVideo.play();
      }
    });

    /**
     * Assumes we have more than one video. Come on. Otherwise it's boring
     */
    const transitionToNextVideo = (currentIndex: number): number => {
      const getNextIndex = (currentIndex: number) => {
        return currentIndex === videos.length - 1 ? 0 : currentIndex + 1;
      };

      const nextIndex = getNextIndex(currentIndex);
      currVideo = videos[nextIndex]!;
      currVideo.play();

      // Reset current video to the beginning for the next play
      videos[currentIndex]!.currentTime = 0;

      // Start preloading next next video if we haven't done it before
      const nextNextVideo = videos[getNextIndex(nextIndex)]!;
      if (!alreadyLoadedVideos.has(nextNextVideo)) {
        nextNextVideo.load();
        alreadyLoadedVideos.add(nextNextVideo);
      }

      return nextIndex;
    };

    // Transitions to index 0 aka plays the first video
    transitionToNextVideo(videos.length - 1);

    videos.forEach((video, index) => {
      video.addEventListener("ended", () => {
        const nextIndex = transitionToNextVideo(index);

        nowPlayingAnchors[index]!.dataset["playing"] = "false";
        nowPlayingAnchors[nextIndex]!.dataset["playing"] = "true";
      });
    });

    const progressBarElt = document.getElementById("progress-bar")!;
    const progressValueElt = document.getElementById("progress-value")!;

    document
      .getElementById("play-pause")!
      .addEventListener("click", () => alert("todo"));

    const dither: Dither = {
      canvasSize: `0×0`,
      backend: "WebGL 2",
      ...structuredClone(DEFAULT_DITHER_SETTINGS),
    };

    const pane = new Pane({
      title: "Info",
      expanded: true,
    });
    pane.registerPlugin(TpEssentialsPlugin);

    const fpsGraph = pane.addBlade({
      view: "fpsgraph",
      label: "FPS",
      min: 0,
      max: 100,
      rows: 2,
    }) as FpsGraphBladeApi;

    fpsGraph.on("tick", (ev) => {
      // Dynamically adjust FPS max bound
      if (ev.target.fps && ev.target.fps > ev.target.max) {
        ev.target.max = ev.target.fps;
      }
    });

    pane.addBinding(dither, "canvasSize", {
      readonly: true,
      label: "Dimensions",
    });
    pane.addBinding(dither, "backend", {
      readonly: true,
      label: "Backend",
    });

    const tab = pane.addTab({
      pages: [{ title: "Configuration" }, { title: "Presets" }],
    });
    const settings = tab.pages[0]!;
    const presets = tab.pages[1]!;

    // Set initial values
    gl.uniform1i(ditherModeUnifLoc, dither.general.mode);
    gl.uniform1i(uvPixelSizeUnifLoc, dither.general.uvPixelSize);
    gl.uniform1i(numQuantizedColorsUnifLoc, dither.general.numQuantizedColors);
    gl.uniform1f(biasUnifLoc, dither.general.bias);
    gl.uniform3f(
      colorAUnifLoc,
      dither.color.a.r,
      dither.color.a.g,
      dither.color.a.b,
    );
    gl.uniform3f(
      colorBUnifLoc,
      dither.color.b.r,
      dither.color.b.g,
      dither.color.b.b,
    );
    gl.uniform1i(bayerMatrixSizeUnifLoc, dither.ordered.bayerMatrixSize);
    gl.uniform1i(orderedDitherSizeUnifLoc, dither.ordered.ditheredSize);

    settings
      .addBinding(dither.general, "mode", {
        label: "Mode",
        options: {
          "Noise-based": DitherMode.NOISE,
          Ordered: DitherMode.ORDERED,
        },
      })
      .on("change", (ev) => {
        const isHidden = ev.value === DitherMode.NOISE;
        orderedSettings.forEach((blade) => (blade.hidden = isHidden));
        gl.uniform1i(ditherModeUnifLoc, ev.value);
      });

    settings
      .addBinding(dither.general, "uvPixelSize", {
        label: "Pixel size",
        min: 1,
        step: 1,
      })
      .on("change", (ev) => gl.uniform1i(uvPixelSizeUnifLoc, ev.value));

    settings
      .addBinding(dither.general, "numQuantizedColors", {
        label: "Color count",
        min: 2,
        max: 32,
        step: 1,
      })
      .on("change", (ev) => gl.uniform1i(numQuantizedColorsUnifLoc, ev.value));

    settings
      .addBinding(dither.general, "bias", {
        label: "Bias",
        min: -1.0,
        max: 1.0,
        step: 0.01,
      })
      .on("change", (ev) => gl.uniform1f(biasUnifLoc, ev.value));

    settings.addBlade({ view: "separator" });

    settings
      .addBinding(dither.color, "a", {
        label: "Color A",
        color: { type: "float" },
        picker: "inline",
      })
      .on("change", ({ value: { r, g, b } }) =>
        gl.uniform3f(colorAUnifLoc, r, g, b),
      );

    settings
      .addBinding(dither.color, "b", {
        label: "Color B",
        color: { type: "float" },
        picker: "inline",
      })
      .on("change", ({ value: { r, g, b } }) =>
        gl.uniform3f(colorBUnifLoc, r, g, b),
      );

    // Not hidden by default
    const orderedSettings: BladeApi[] = [
      settings.addBlade({ view: "separator" }),
      settings
        .addBinding(dither.ordered, "bayerMatrixSize", {
          label: "Bayer matrix",
          options: {
            "2×2": BayerMatrixSize.TWO_BY_TWO,
            "4×4": BayerMatrixSize.FOUR_BY_FOUR,
            "8×8": BayerMatrixSize.EIGHT_BY_EIGHT,
          },
        })
        .on("change", (ev) => gl.uniform1i(bayerMatrixSizeUnifLoc, ev.value)),
      settings
        .addBinding(dither.ordered, "ditheredSize", {
          label: "Dither size",
          min: 1,
          step: 1,
        })
        .on("change", (ev) => gl.uniform1i(orderedDitherSizeUnifLoc, ev.value)),
    ];

    const applyDitherSettings = (d: Dither, newSettings: DitherSettings) => {
      d.general.mode = newSettings.general.mode;
      d.general.uvPixelSize = newSettings.general.uvPixelSize;
      d.general.numQuantizedColors = newSettings.general.numQuantizedColors;
      d.general.bias = newSettings.general.bias;

      d.color.a = newSettings.color.a;
      d.color.b = newSettings.color.b;

      d.ordered.bayerMatrixSize = newSettings.ordered.bayerMatrixSize;
      d.ordered.ditheredSize = newSettings.ordered.ditheredSize;
    };

    DITHER_PRESETS.forEach((preset, index) =>
      presets
        .addButton({
          title: index !== 0 ? index.toString() : "Reset to default",
        })
        .on("click", () => {
          applyDitherSettings(dither, preset);
          settings.refresh();
        }),
    );

    const draw: VideoFrameRequestCallback = () => {
      fpsGraph.begin();

      // Check if canvas needs to be resized. See https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
      if (
        canvas.width !== canvas.clientWidth ||
        canvas.height !== canvas.clientHeight
      ) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.uniform2i(dimensionsUnifLoc, gl.canvas.width, gl.canvas.height);
        dither.canvasSize = `${gl.canvas.width}×${gl.canvas.height}`;
      }

      const progress = saturate(
        currVideo.duration > 0 ? currVideo.currentTime / currVideo.duration : 0,
      );
      progressBarElt.setAttribute(
        "aria-valuenow",
        Math.round(progress * 100).toString(),
      );
      progressValueElt.style.transform = `scaleX(${progress})`;

      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        currVideo,
      );

      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);

      fpsGraph.end();

      currVideo.requestVideoFrameCallback(draw);
    };

    currVideo.requestVideoFrameCallback(draw);
  };

  run();
</script>
